# Day 002: Mastering Python Lists

Welcome to Day 2. Lists are arguably the most fundamental data structure in Python. For an intermediate developer, mastering lists means moving beyond basic `append` and `pop` operations. It involves a deep understanding of slicing, list comprehensions, and the critical distinction between methods that return a new list versus those that modify a list in-place.

### Core Concept: Slicing and List Comprehensions

**Slicing:** This is the most Pythonic way to access sub-sections of a list. The syntax `my_list[start:stop:step]` is incredibly powerful for creating copies or extracting elements. A key feature is that slicing always returns a  **new list** , leaving the original untouched. This is a form of immutability that helps prevent bugs.

**List Comprehensions:** These provide a concise, readable, and often more performant way to create a new list by applying an expression to each item in an existing iterable. They are a hallmark of idiomatic Python code.

```py
# Create a new list of squared numbers
squares = [x**2 for x in range(10) if x % 2 == 0]
# Output: [0, 4, 16, 36, 64]

```

### Today's Exercises

#### Exercise 1: Fundamentals - Slicing Practice

**Concept:** This exercise focuses on mastering the extended slice syntax (`[start:stop:step]`) to create new, transformed lists in a single, expressive line of code.

Problem Statement:

Write a function reverse_and_slice that takes a list and returns a new list containing every other element from the original list, but in reverse order.

**Example:**

* Input: `[10, 20, 30, 40, 50, 60]`
* Output: `[60, 40, 20]`

#### Exercise 2: Practical Application - Product Filtering

**Concept:** This exercise uses a list comprehension to filter and transform data, a very common task in data processing and back-end development.

Problem Statement:

Write a function filter_products that takes a list of product dictionaries. It should return a new list containing only the names of products that are both in stock ("in_stock": True) and cost more than a specified minimum price.

**Key Requirements:**

* You must use a **list comprehension** for this solution.

#### Exercise 3: Interview Challenge - Rotate List In-Place

**Concept:** This is a classic interview question that tests your understanding of slice *assignment* and in-place modification, which is a more advanced technique than simple slicing.

Problem Statement:

Write a function rotate_list that rotates a list nums to the right by k steps. This modification must be done in-place, meaning you modify the original list directly. The function should not return anything.

**Key Requirements:**

* The function must modify the list in-place.
* Handle cases where `k` is greater than the length of the list.

### Tricky Interview Questions & Answers

**1. "You used slice assignment (`nums[:] = ...`) to modify the list in-place. What is the difference between that and a simple assignment (`nums = ...`) inside a function?"**

* **Answer:** "This is a critical distinction related to how Python handles object references. When you do a simple assignment like `nums = ...`, you are changing the local variable `nums` to point to a completely new list object in memory. The original list outside the function remains unchanged. When you use slice assignment like `nums[:] = ...`, you are not changing the reference; you are modifying the *contents* of the original object that `nums` points to. This is the correct way to achieve an in-place modification that is visible outside the function's scope."

**2. "What is the difference between a shallow copy and a deep copy of a list, especially if it contains other lists?"**

* **Answer:** "A shallow copy (created with `my_list.copy()` or `my_list[:]`) creates a new list object, but it only copies the *references* to the objects inside the original list. If the list contains simple elements like numbers or strings, it behaves like a full copy. However, if the list contains mutable objects like other lists, both the original and the shallow copy will contain references to the  *exact same inner lists* . Modifying an inner list in one will affect the other. A deep copy (using the `copy.deepcopy()` function) solves this by recursively creating new copies of everything, including all nested objects, ensuring the two lists are completely independent."

**3. "Is a list comprehension always better than a `for` loop?"**

* **Answer:** "Not always, but often. For creating a new list based on an existing iterable, a list comprehension is generally preferred because it's more concise, readable, and can be faster due to optimizations in the Python interpreter. However, a traditional `for` loop is the better choice when the logic is too complex to fit cleanly into a comprehension, if you need to perform actions on more than one list, or if you don't need to create a new list at all (e.g., you're just printing items or modifying them in-place)."

**4. "What does the `key` argument in the `list.sort()` method do? Provide a practical example."**

* **Answer:** "The `key` argument allows you to provide a function that is called on every element of the list before making comparisons. The return value of this function is then used as the basis for sorting. It's incredibly powerful for custom sorting logic without having to write a complex comparison function. A practical example would be sorting a list of dictionaries by a specific key, like sorting a list of users by their age: `users.sort(key=lambda user: user['age'])`. This sorts the list in-place based on the 'age' value in each user dictionary."
